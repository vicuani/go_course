/*

Виконати пошук телефонних номерів у файлі з даними контактів.
Задача полягає в тому, щоб створити регулярний вираз, який можна використовувати для знаходження телефонних номерів, записаних у різних форматах.
Наприклад, ви можете почати з використання виразу, який знаходить номери телефонів, що складаються з 10 цифр,
а потім розширити його, додавши підтримку різних форматів, наприклад, номери з круглими дужками, пробілами та дефісами.

Для відпрацювання регулярного виразу дивіться https://regex101.com/.

Далі треба перезаписати цей файл із іменами та номерами телефонів,
щоб усі номери були в одному форматі, а саме (000) 11-22-333.

Файл із текстом у директорії hw.

*/

package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strings"
)

func main() {
	inputFile, err := os.Open("input.txt")
	if err != nil {
		panic(err)
	}
	defer inputFile.Close()

	outputFile, err := os.Create("output.txt")
	if err != nil {
		panic(err)
	}
	defer outputFile.Close()

	namePattern := regexp.MustCompile(`^(.*?)\s*-\s*`)
	/*
		Very complicated regex generated by ChatGPT (but it really works)

		1.	(?: ... ):
			This is a non-capturing group. It groups the regex parts together without capturing the matched text for back-referencing later.
		2.	\+?\d{1,3}:
			\+?: This matches an optional plus sign (+). The ? means “zero or one occurrence” of the preceding character.
			\d{1,3}: This matches 1 to 3 digits. The \d represents any digit (0-9), and {1,3} specifies that it can occur between 1 and 3 times.
		3.	|:
			This is a logical OR operator. It allows for matching either the left side or the right side of the operator.
		4.	\d{1,3}:
			This matches 1 to 3 digits. This part of the pattern allows for matching area codes or country codes that do not include the plus sign.
		5.	? (after the non-capturing group):
			This indicates that the whole non-capturing group (the area code part) is optional,
			meaning that a phone number can start with this code or just go straight to the digits.
		6.	[\s\-\/\.()]*:
			This matches zero or more occurrences of whitespace characters (\s), hyphens (-), slashes (/), periods (.), or parentheses (( and )).
			This allows for various separators between the number parts.
		7.	\d{1,3}:
			This matches 1 to 3 digits. It appears multiple times in the pattern, indicating that the phone number can be divided into several segments.
		8.	[\s\-\/\.()]* (repeated):
			This allows for separators between the segments of digits. There are four instances of \d{1,3} followed by the same separator pattern.
			This means the phone number can consist of four groups of up to three digits, allowing for different formats.
		9.	[\s\-\/\.()]*\d{0,2}:
			This part matches an optional group of 0 to 2 digits at the end of the phone number.
			This can accommodate various phone number formats where the last segment may not always have three digits (like local extensions or short codes).
	*/
	phonePattern := regexp.MustCompile(
		`(?:\+?\d{1,3}|$begin:math:text$\d{1,3}$end:math:text$)?[\s\-\/\.()]*\d{1,3}[\s\-\/\.()]*\d{1,3}[\s\-\/\.()]*\d{1,3}[\s\-\/\.()]*\d{1,3}[\s\-\/\.()]*\d{0,2}`)

	scanner := bufio.NewScanner(inputFile)
	for scanner.Scan() {
		line := scanner.Text()

		name := namePattern.FindStringSubmatch(line)
		phone := phonePattern.FindString(line)

		if len(name) > 1 {
			cleanPhone := strings.TrimSpace(phone)
			cleanPhone = strings.TrimPrefix(cleanPhone, "-")
			cleanPhone = extractDigits(cleanPhone)

			formattedPhone, err := formatPhone(cleanPhone)
			if err != nil {
				panic(err)
			} else {
				outputLine := fmt.Sprintf("Name: %s, Phone: %s\n", strings.TrimSpace(name[1]), formattedPhone)
				outputFile.WriteString(outputLine)
			}
		}
	}

	fmt.Println("Program finished successfully, the answer is in output.txt file")
}

func extractDigits(phone string) string {
	re := regexp.MustCompile(`\d`)
	digits := re.FindAllString(phone, -1)

	return strings.Join(digits, "")
}

func formatPhone(digits string) (string, error) {
	if len(digits) == 12 {
		return fmt.Sprintf("(%s) %s-%s-%s", digits[3:6], digits[6:8], digits[8:10], digits[10:]), nil // For +380 (12 digits)
	} else if len(digits) == 10 {
		return fmt.Sprintf("(%s) %s-%s-%s", digits[0:3], digits[3:5], digits[5:7], digits[7:]), nil // For 10 digits
	}
	return "", fmt.Errorf("incorrect number")
}